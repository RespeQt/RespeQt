mads 2.0.8
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/rcl.asm
     1 				;  rlc.s - RespeQt client
     2 				;
     3 				;  Copyright (c) 2016 by Jonathan Halliday <fjc@atari8.co.uk>
     4 				;
     5 				;  This program is free software; you can redistribute it and/or modify
     6 				;  it under the terms of the GNU General Public License as published by
     7 				;  the Free Software Foundation; either version 2 of the License, or
     8 				;  (at your option) any later version.
     9 				;
    10 				;  This program is distributed in the hope that it will be useful,
    11 				;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    12 				;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13 				;  GNU General Public License for more details.
    14 				;
    15 				;  You should have received a copy of the GNU General Public License
    16 				;  along with this program; if not, write to the Free Software
    17 				;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    18 				;
    19 				;  2020-01-27 Allow to run with RealDOS 30
    20 				;
    21
    22 					icl 'equ.asm'
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/equ.asm
     1 				;  rlc.inc - RespeQt client includes
     2 				;
     3 				;  Copyright (c) 2016 by Jonathan Halliday <fjc@atari8.co.uk>
     4 				;
     5 				;  This program is free software; you can redistribute it and/or modify
     6 				;  it under the terms of the GNU General Public License as published by
     7 				;  the Free Software Foundation; either version 2 of the License, or
     8 				;  (at your option) any later version.
     9 				;
    10 				;  This program is distributed in the hope that it will be useful,
    11 				;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    12 				;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13 				;  GNU General Public License for more details.
    14 				;
    15 				;  You should have received a copy of the GNU General Public License
    16 				;  along with this program; if not, write to the Free Software
    17 				;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    18 				;
    19 = 0300			DDEVIC	equ $0300
    20 = 0301			DUNIT	equ $0301
    21 = 0302			DCOMND	equ $0302
    22 = 0303			DSTATS	equ $0303
    23 = 0304			DBUFLO	equ $0304
    24 = 0305			DBUFHI	equ $0305
    25 = 0306			DTIMLO	equ $0306
    26 = 0307			DUNUSE	equ $0307
    27 = 0308			DBYTLO	equ $0308
    28 = 0309			DBYTHI	equ $0309
    29 = 030A			DAUX1	equ $030A
    30 = 030B			DAUX2	equ $030B
    31 = 003C			NOCKSM	equ $003C
    32
    33 = 0342			iccom	equ $0342
    34 = 0344			icbadr	equ $0344
    35 = 0346			icptl	equ $0346
    36 = 0347			icpth	equ $0347
    37 = 0348			icblen	equ $0348
    38 = 034A			icaux1	equ $034A
    39 = 034B			icaux2	equ $034B
    40
    41 = E456			ciov	equ $e456
    42
    43 = D301			portb	equ $d301
    44
    45 = 000A			DOSVEC	equ $0A
    46 = 000C			DOSINI	equ $0C
    47
    48 = E459			SIOV	equ $E459
    49
    50 = FFC3			I_SETTD	equ $FFC3
    51 = FFC6			I_TDON	equ $FFC6
    52
    53
    54 					.enum Cmd
    55 = 0091			GetDR       = $91	
    56 = 0092			GetSL       = $92
    57 = 0093			GetTD	    = $93
    58 = 0094			Swap		= $94
    59 = 0095			Unmount		= $95
    60 = 0096			Mount		    = $96
    61 = 0097			CreateAndMount	= $97
    62 = 0098			AutoToggle	    = $98
    63 = 0099			Save            = $99
    64 					.ende
    65
    66 					.enum DCB
    67 = 0000			GetDR	
    68 = 0001			GetSL
    69 = 0002			GetTD
    70 = 0003			Swap
    71 = 0004			Unmount
    72 = 0005			Mount
    73 = 0006			CreateAndMount
    74 = 0007			AutoToggle
    75 = 0008			GetDrvNum
    76 = 0009			Save
    77 					.ende
    78
    79
    80 = 0021			comfnam	equ $21
    81 = 000A			comtab	equ $0A
    82
    83 					org $80
    84
    85 = 0080			Temp1		.ds 2
    86 = 0082			Temp2		.ds 2
    87 = 0084			Temp3		.ds 2
    88 = 0086			Temp4		.ds 2
    89 = 0088			LeadingZeroFlag	.ds 1
    90 = 0089			ArgIndex	.ds 1
    91 = 008A			FieldWidth	.ds 1
    92 = 008B			StringIndex	.ds 1
    93
    94 				.macro ldxy
    95 					ldx #< :1
    96 					ldy #> :1
    97 				.endm
    98
    99 				.macro ldax
   100 					lda #< :1
   101 					ldx #> :1
   102 				.endm
   103
   104 				.macro stax
   105 					sta :1
   106 					stx :1+1
   107 				.endm
   108
    23
    24 					org $4000
    25
    26 				Start
    27 FFFF> 4000-4990> 20 CC + 	jsr printf
    28 4003 52 65 61 6C 44 6F + 	.byte 'RealDos RespeQt Client',155
    29 401A 9B 00			.byte 155,0
    30 					
    31 401C AD 00 07			lda $0700
    32 401F C9 52			cmp #'R'
    33 4021 F0 1C			beq IsRealDos
    34 					
    35 4023 20 CC 47			jsr printf
    36 4026 52 65 61 6C 44 6F + 	.byte 'RealDos is required!',155,0
    37 403C 4C 65 47			jmp Exit
    38 					
    39 403F			IsRealDos
    40 403F A0 05			ldy #5
    41 4041 A2 02			ldx #2
    42 4043			@
    43 4043 B1 0A			lda (comtab),y
    44 4045 9D 80 47			sta Crunch,x
    45 4048 88				dey
    46 4049 CA				dex
    47 404A D0 F7			bne @-
    48
    49 404C			MainLoop	
    50 404C 20 80 47			jsr Crunch	; get next arg
    51 404F D0 06			bne GotArg
    52 4051 2C F3 4A			bit ArgFlag	; if no args, disaplay usage
    53 4054 10 12			bpl BadArg
    54 4056 60				rts		; otherwise we're done
    55 4057			GotArg
    56 4057 38				sec
    57 4058 6E F3 4A			ror ArgFlag	; if we get at least one argument, don't display usage instructions
    58 405B A0 23			ldy #comfnam+2	; step past drive spec
    59 405D 20 C1 40			jsr GetNextChar
    60 4060 C9 54			cmp #'T'	; TD command?
    61 4062 F0 07			beq CheckTDCmd
    62 4064 C9 44			cmp #'D'
    63 4066 F0 12			beq CheckDskCmd
    64 					
    65 4068			BadArg
    66 4068 4C AB 45			jmp Usage
    67 					
    68 				;	Check TD command
    69 					
    70 406B			.proc CheckTDCmd		; parse TD command
    71 406B 20 C1 40			jsr GetNextChar
    72 406E A2 02			ldx #2
    73 4070			@
    74 4070 DD A0 40			cmp TDCmdList,x
    75 4073 F0 19			beq Execute
    76 4075 CA				dex
    77 4076 10 F8			bpl @-
    78 4078 30 EE			bmi BadArg
    79 					.endp
    80
    81 				;	Check disk command
    82
    83 407A			.proc CheckDskCmd
    84 407A 20 C1 40			jsr GetNextChar
    85 407D A2 07			ldx #7
    86 407F			@
    87 407F DD A3 40			cmp DskCmdList,x
    88 4082 F0 05			beq Found
    89 4084 CA				dex
    90 4085 10 F8			bpl @-
    91 4087 30 DF			bmi BadArg
    92 4089			Found
    93 4089 8A				txa
    94 408A 18				clc
    95 408B 69 03			adc #3	; skip TD commands
    96 408D AA				tax
    97 				.endp
    98
    99 408E			.proc Execute
   100 408E A9 40			lda #> [Return-1]
   101 4090 48				pha
   102 4091 A9 9C			lda #< [Return-1]
   103 4093 48				pha
   104 4094 BD B6 40			lda CmdAddressHi,x
   105 4097 48				pha
   106 4098 BD AB 40			lda CmdAddressLo,x
   107 409B 48				pha
   108 409C 60				rts
   109 				.endp
   110 					
   111 					
   112 409D			.proc Return
   113 409D 90 AD			bcc MainLoop
   114 409F 60				rts
   115 				.endp
   116 					
   117
   118 40A0			TDCmdList
   119 40A0 53 4F 46			.byte 'SOF'	; 0 = set td, 1 = set td and enable td line, 2 = set td and disable td line
   120 40A3			DskCmdList
   121 40A3 4D 4E 55 53 41 4F + 	.byte 'MNUSAODR';
   122
   123 40AB			CmdAddressLo
   124 40AB 03 06 11 1D 1F 9B + 	.byte <[GetTD-1], <[GetTDOn-1], <[GetTDOff-1], <[Mount-1], <[CreateAndMount-1], <[UnMount-1], <[Swap-1], <[CommitOn-1], <[Commitoff-1], <[SlotName-1], <[ListDir-1]
   125 40B6			CmdAddressHi
   126 40B6 41 41 41 43 43 42 + 	.byte >[GetTD-1], >[GetTDOn-1], >[GetTDOff-1], >[Mount-1], >[CreateAndMount-1], >[UnMount-1], >[Swap-1], >[CommitOn-1], >[Commitoff-1], >[SlotName-1], >[ListDir-1]
   127 					
   128 					
   129 				//
   130 				//	Get next character from arg
   131 				//
   132 40C1			.proc GetNextChar
   133 40C1 C8				iny
   134 40C2 B1 0A			lda (comtab),y
   135 40C4 20 39 49			jsr ToUpper
   136 40C7 C9 9B			cmp #155
   137 40C9 60				rts
   138 				.endp
   139
   140 				//
   141 				//	Get drive spec and allow '*'
   142 				//
   143
   144 40CA			.proc GetDrvWC
   145 40CA 38				sec
   146 40CB 24				.byte $24
   147 				.endp
   148
   149 				//
   150 				//	Get drive spec, disallowing '*'
   151 				//
   152
   153 40CC			.proc GetDrv
   154 40CC 18				clc
   155 				.endp
   156
   157 				//
   158 				//	Get next character from arg buffer and see if it's a valid drive ID
   159 				//	This includes 1-9 and A-O, and optionally '*'.
   160 				//	Server expects everything to have $30 subtracted, so while 1-9 ($31-39) end up as $01-$09,
   161 				//	J-O ($4A-4F, for drives 10 through 15) are encoded as $1A-$1F and then have $10 subtracted
   162 				//	at the server end. Wildcard character, meanwhile, ends up as $FA (-6).
   163 				//	This means when converting the resulting drive ID back to integer form, we add $30 regardless,
   164 				//	changing $1A-$1F to $4A-$4F.
   165 				//	Might be nice if server accepted $01-$0F for the drive number and $00 for 'all drives'.
   166 				//
   167
   168 40CD			.proc GetDriveID
   169 40CD 66 80			ror Temp1	; wildcard flag
   170 40CF 20 C1 40			jsr GetNextChar
   171 40D2 B0 2F			bcs Abort
   172 40D4 24 80			bit Temp1
   173 40D6 10 08			bpl @+
   174 40D8 C9 2A			cmp #'*'
   175 40DA D0 04			bne @+
   176 40DC A9 FA			lda #$FA	; '*' - $30
   177 40DE 18				clc
   178 40DF 60				rts
   179 40E0			@
   180 40E0 C9 3A			cmp #'9'+1
   181 40E2 B0 08			bcs NotDigit
   182 40E4 E9 2F			sbc #'0'-1
   183 40E6 90 1A			bcc Bad
   184 40E8 F0 18			beq Bad		; disallow 0
   185 40EA 18				clc
   186 40EB 60				rts
   187 40EC			NotDigit
   188 40EC C9 41			cmp #'A'	; handle A-I for 1-9
   189 40EE 90 12			bcc Bad
   190 40F0 C9 4A			cmp #'J'
   191 40F2 B0 04			bcs @+
   192 40F4 E9 3F			sbc #'A'-2	; carry is clear
   193 40F6 18				clc
   194 40F7 60				rts
   195 40F8			@
   196 40F8 C9 50			cmp #'O'+1
   197 40FA B0 06			bcs Bad
   198 40FC E9 2F			sbc #'0'-1	; carry is clear, so subtract one less
   199 40FE 90 02			bcc Bad
   200 4100			OK
   201 4100 18				clc
   202 4101 60				rts
   203 4102			Bad
   204 4102 38				sec
   205 4103			Abort
   206 4103 60				rts
   207 					.endp
   208 					
   209
   210 				//
   211 				//	TS: Time Set
   212 				//
   213 					
   214 4104			.proc GetTD
   215 4104 4C 1D 41			jmp SetTD	; read time/date from server and set clock
   216 				.endp
   217
   218
   219 				//
   220 				//	TO: Time set, enable TD line
   221 				//
   222
   223 4107			.proc GetTDOn
   224 4107 20 1D 41			jsr SetTD
   225 410A B0 05			bcs Abort1
   226 410C A0 01			ldy #1
   227 410E 20 D4 41			jsr TDLineOnOff
   228 4111			Abort1
   229 4111 60				rts
   230 				.endp
   231
   232
   233 				//
   234 				//	TF: Time set, disable TD line
   235 				//
   236
   237 4112			.proc GetTDOff
   238 4112 20 1D 41			jsr SetTD
   239 4115 B0 05			bcs Abort2
   240 4117 A0 00			ldy #0
   241 4119 20 D4 41			jsr TDLineOnOff
   242 411C			Abort2
   243 411C 60				rts
   244 				.endp
   245
   246
   247
   248
   249 				//
   250 				//	Read date and time from the server and set the clock
   251 				//
   252
   253 411D			.proc SetTD
   254 				;	jsr Printf
   255 				;	.byte 'Polling server for date/time',155,0
   256
   257 411D A9 02			lda #DCB.GetTD
   258 411F 20 90 47			jsr SetUpDCB
   259 4122 20 59 E4			jsr SIOV
   260 4125 10 1A			bpl OK5
   261 4127 20 CC 47			jsr Printf
   262 412A 4E 6F 20 73 65 72 + 	.byte 'No server response!',155,0
   263 413F 38				sec
   264 4140 60				rts
   265 					
   266 4141			OK5	; got date and time from server, so attempt to set Sparta clock
   267 4141 20 CC 47			jsr Printf
   268 4144 44 61 74 65 20 72 + 	.byte 'Date received from server...',155,0
   269 					
   270 4162 AD 01 07			lda $701
   271 4165 C9 44			cmp #$44
   272 4167 B0 21			bcs IsSDX2
   273
   274 4169 A2 05			ldx #5
   275 416B A0 12			ldy #$0D+$05
   276 416D			@
   277 416D BD 1F 4B			lda IOBuf,x
   278 4170 91 0A			sta (comtab),y
   279 4172 88				dey
   280 4173 CA				dex
   281 4174 10 F7			bpl @-
   282 					
   283 4176 AD 01 D3			lda portb
   284 4179 48				pha
   285 417A 29 FE			and #$FE
   286 417C 8D 01 D3			sta portb
   287 417F 20 C3 FF			jsr I_SETTD	; this will fail if the vectors aren't there
   288 4182 68				pla
   289 4183 8D 01 D3			sta portb
   290 4186 90 38			bcc TDSetOK
   291 4188 B0 17			bcs TDSetFailed
   292 					
   293 418A			IsSDX2			; with SDX, use kernel
   294 418A A2 05			ldx #5
   295 418C			@
   296 418C BD 1F 4B			lda IOBuf,x
   297 418F 9D 7B 07			sta $077B,x
   298 4192 CA				dex
   299 4193 10 F7			bpl @-
   300 					
   301 4195 A0 65			ldy #$65
   302 					
   303 4197 A9 10			lda #$10
   304 4199 8D 61 07			sta $0761
   305 419C 20 03 07			jsr $0703
   306 419F F0 1F			beq TDSetOK
   307 					
   308 41A1			TDSetFailed
   309 41A1 20 CC 47			jsr Printf
   310 41A4 45 72 72 6F 72 20 + 	.byte 'Error setting time/date!',155,0
   311 41BE 38				sec
   312 41BF 60				rts
   313 					
   314 41C0			TDSetOK
   315 41C0 20 CC 47			jsr Printf
   316 41C3 54 69 6D 65 2F 64 + 	.byte 'Time/date set',155,0
   317 41D2 18				clc
   318 41D3 60				rts
   319 				.endp
   320
   321 				//
   322 				//	Enable or disable the TD Line
   323 				//	Y = 0: Turn off
   324 				//	Y = 1: Turn on
   325 				//
   326 41D4			.proc TDLineOnOff
   327 41D4 AD 01 07			lda $701
   328 41D7 C9 44			cmp #$44
   329 41D9 B0 13			bcs IsSDX1
   330 					
   331 41DB AD 01 D3			lda portb
   332 41DE 48				pha
   333 41DF 29 FE			and #$FE
   334 41E1 8D 01 D3			sta portb
   335 41E4 20 C6 FF			jsr I_TDON
   336 41E7 68				pla
   337 41E8 8D 01 D3			sta portb
   338 41EB B0 19			bcs TDOnFailed
   339 41ED 60				rts
   340 					
   341 41EE			IsSDX1
   342 41EE 84 82			sty Temp2
   343 41F0				ldax Symbol	; under SDX, enable TD using kernel
Macro: LDAX [Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/equ.asm]
     1 41F0 A9 EA			lda #< SYMBOL
     2 41F2 A2 4A			ldx #> SYMBOL
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/rcl.asm
   344 41F4 20 EB 07			jsr $07EB	; get symbol address
   345 41F7 30 0D			bmi TDOnFailed
   346
   347 41F9				stax TDVec+1	; store address
Macro: STAX [Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/equ.asm]
     1 41F9 8D 02 42			sta TDVEC+1
     2 41FC 8E 03 42			stx TDVEC+1+1
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/rcl.asm
   348 41FF A4 82			ldy Temp2
   349 4201			TDVec
   350 4201 20 FF FF			jsr $FFFF	; should really check for errors...
   351 4204 18				clc
   352 4205 60				rts
   353 					
   354 4206			TDOnFailed
   355 4206 20 CC 47			jsr Printf
   356 4209 45 72 72 6F 72 20 + 	.byte 'Error enabling TD Line!',155,0
   357 4222 38				sec
   358 4223 60				rts
   359 				.endp
   360
   361
   362
   363
   364 				//
   365 				//	DS: Disk Swap
   366 				//
   367
   368 4224			.proc Swap
   369 4224 20 CC 40			jsr GetDrv
   370 4227 B0 70			bcs Error
   371 4229 8D F5 4A			sta Slot
   372 422C 20 8C 47			jsr MakeDriveID	; make some drive IDs for later
   373 422F 8D F7 4A			sta DriveID1
   374 4232 20 CC 40			jsr GetDrv
   375 4235 B0 62			bcs Error
   376 4237 8D F6 4A			sta Drive
   377 423A 20 8C 47			jsr MakeDriveID
   378 423D 8D F8 4A			sta DriveID2
   379 4240 20 C1 40			jsr GetNextChar
   380 4243 90 54			bcc Error	; make sure next char is end of string
   381
   382 4245 A9 03			lda #DCB.Swap
   383 4247 20 90 47			jsr SetUpDCB
   384 424A AD F5 4A 8D 0A 03		mva Slot DAUX1
   385 4250 AD F6 4A 8D 0B 03		mva Drive DAUX2
   386 4256 20 59 E4			jsr SIOV
   387 4259 10 1C			bpl OK1
   388 425B 20 CC 47			jsr Printf
   389 425E 45 72 72 6F 72 20 + 	.byte 'Error swapping disks!',155,0
   390 4275 38				sec
   391 4276 60				rts
   392 4277			OK1
   393 4277 20 CC 47			jsr Printf
   394 427A 53 77 61 70 70 65 + 	.byte 'Swapped disk %c with %c',155,0
   395 4293 F7 4A F8 4A			.word DriveID1,DriveID2
   396 4297 18				clc
   397 4298 60				rts
   398 4299			Error
   399 4299 4C AB 45			jmp Usage
   400 				.endp
   401 					
   402 					
   403 				//
   404 				//	DU: Unmount disk
   405 				//
   406
   407 429C			.proc UnMount
   408 429C 20 CA 40			jsr GetDrvWC
   409 429F B0 7A			bcs Error
   410 42A1 8D F6 4A			sta Drive
   411 42A4 20 C1 40			jsr GetNextChar	; make sure next char is end of arg
   412 42A7 90 72			bcc Error
   413
   414 42A9 A9 04			lda #DCB.Unmount
   415 42AB 20 90 47			jsr SetUpDCB
   416 42AE AD F6 4A 8D 0B 03		mva Drive DAUX2
   417 42B4 20 59 E4			jsr SIOV
   418 42B7 10 1F			bpl OK6	
   419 42B9 20 CC 47			jsr Printf
   420 42BC 45 72 72 6F 72 20 + 	.byte 'Error unmounting volume!',155,0
   421 42D6 38				sec
   422 42D7 60				rts
   423 42D8			OK6
   424 42D8 AD F6 4A			lda Drive
   425 42DB C9 FA			cmp #-6		; bizarrely, '*' must be encoded as $FA (0 might be a better choice for 'all drives')
   426 42DD F0 21			beq AllDrives
   427 42DF 20 8C 47			jsr MakeDriveID
   428 42E2 8D F7 4A			sta DriveID1
   429 42E5 20 CC 47			jsr Printf
   430 42E8 44 72 69 76 65 20 + 	.byte 'Drive %c unmounted',155,0
   431 42FC F7 4A			.word DriveID1
   432 42FE 18				clc
   433 42FF 60				rts
   434 4300			AllDrives
   435 4300 20 CC 47			jsr Printf
   436 4303 41 6C 6C 20 64 72 + 	.byte 'All drives unmounted',155,0
   437 4319 18				clc
   438 431A 60				rts
   439 431B			Error
   440 431B 4C AB 45			jmp Usage
   441 				.endp
   442
   443
   444 				//
   445 				//	DM: Mount disk
   446 				//
   447
   448 431E			.proc Mount
   449 431E 18				clc
   450 431F 24				.byte $24	; BIT ZP
   451 				.endp
   452
   453
   454 				//
   455 				//	DN: Create and mount
   456 				//
   457
   458 4320			.proc CreateAndMount
   459 4320 38				sec
   460 				.endp
   461
   462
   463 4321			.proc DoMount
   464 4321 6E F4 4A			ror CreateFlag	; c = 1: Create and Mount
   465 4324 A9 20 85 80			mva #$20 Temp1
   466 4328 A2 00			ldx #0
   467 432A			Loop1
   468 432A C8				iny
   469 432B B1 0A			lda (comtab),y
   470 432D F0 25			beq Fin
   471 432F C9 9B			cmp #155
   472 4331 F0 21			beq Fin
   473 4333 20 39 49			jsr ToUpper
   474 4336 24 80			bit Temp1	; don't add to filename if we already found second period
   475 4338 30 14			bmi Store
   476 433A C9 2E			cmp #'.'
   477 433C D0 0D			bne NotPeriod
   478 433E 06 80			asl Temp1
   479 4340 10 09			bpl NotPeriod	; we terminate the printable copy of the filename on the second period we encounter
   480 4342 A9 00			lda #0		; if so, terminate filename
   481 4344 9D 0F 4B			sta FileName,x
   482 4347 A9 2E			lda #'.'
   483 4349 D0 03			bne Store
   484 434B			NotPeriod
   485 434B 9D 0F 4B			sta FileName,x
   486 434E			Store
   487 434E 9D 1F 4B			sta IOBuf,x
   488 4351 E8				inx
   489 4352 D0 D6			bne Loop1
   490 4354			Fin
   491 4354 A9 00			lda #0
   492 4356 9D 1F 4B			sta IOBuf,x
   493 4359 9D 0F 4B			sta FileName,x
   494 					
   495 435C A9 05			lda #DCB.Mount
   496 435E 2C F4 4A			bit CreateFlag
   497 4361 10 02			spl
   498 4363 A9 06			lda #DCB.CreateAndMount
   499 4365 20 90 47			jsr SetUpDCB
   500 4368 20 59 E4			jsr SIOV
   501 436B 10 1C			bpl OK3
   502 436D 20 CC 47			jsr Printf
   503 4370 45 72 72 6F 72 20 + 	.byte 'Error mounting image!',155,0
   504 4387 38				sec
   505 4388 60				rts
   506
   507 4389			OK3			; image mounted, so now get drive number
   508 4389 A9 08			lda #DCB.GetDrvNum
   509 438B 20 90 47			jsr SetUpDCB
   510 438E 20 59 E4			jsr SIOV
   511 4391 10 24			bpl OK4
   512 					
   513 4393 20 CC 47			jsr Printf
   514 4396 45 72 72 6F 72 20 + 	.byte 'Error obtaining drive number!',155,0
   515 43B5 38				sec
   516 43B6 60				rts
   517 43B7			OK4
   518 43B7 AD 1F 4B			lda IOBuf
   519 43BA 18				clc
   520 43BB 69 01			adc #1	; bump drive number since server returns drive-1
   521 43BD 20 8C 47			jsr MakeDriveID
   522 43C0 8D F7 4A			sta DriveID1
   523 43C3 20 CC 47			jsr Printf
   524 43C6 25 73 20 6D 6F 75 + 	.byte '%s mounted on drive %c',155,0
   525 43DE 0F 4B F7 4A			.word Filename,DriveID1
   526 43E2 18				clc
   527 43E3 60				rts
   528 				.endp
   529
   530
   531 43E4			.proc SlotName
   532 43E4 20 CA 40		    jsr GetDrvWC
   533 43E7 B0 44		    bcs Error1
   534 43E9 8D F6 4A		    sta drive
   535 43EC C9 FA			cmp #$FA
   536 43EE D0 39			bne OneSlot
   537 43F0			MultiSlot
   538 43F0 A2 01		    ldx #$01
   539 43F2 8E 1D 4C		    stx lp
   540 43F5			LOOPa
   541 43F5 8A			    txa  
   542 43F6 8D F6 4A		    sta drive
   543 43F9 20 31 44		    jsr getSlotFileName
   544 43FC AD 1D 4C 18 69 01 +     adb lp #01
   545 4405 AE 1D 4C		    ldx lp
   546 4408 E0 0A		    cpx #$0A
   547 440A D0 E9		    bne LOOPa
   548
   549 440C A2 1A		    ldx #$1A
   550 440E 8E 1D 4C		    stx lp
   551 4411			LOOPb
   552 4411 8A			    txa  
   553 4412 8D F6 4A		    sta drive
   554 4415 20 31 44		    jsr getSlotFileName
   555 4418 AD 1D 4C 18 69 01 +     adb lp #01
   556 4421 AE 1D 4C		    ldx lp
   557 4424 E0 20		    cpx #$20
   558 4426 D0 E9		    bne LOOPb
   559 4428 60			    rts
   560 				        
   561 4429			OneSlot
   562 4429 20 31 44		    jsr getSlotFileName
   563 442C 60			    rts
   564 442D			Error1
   565 442D 4C AB 45			jmp Usage
   566 4430 60			    rts
   567 				.endp
   568
   569
   570
   571 4431			.proc getSlotFileName
   572 4431 A9 01		   lda #DCB.GetSL
   573 4433 20 90 47		   jsr SetUpDCB
   574 4436 AD F6 4A 8D 0A 03	   mva drive DAUX1
   575 443C 20 59 E4		   jsr SIOV
   576 443F 10 1A		   bpl OKa
   577 4441 20 CC 47		   jsr Printf
   578 4444 4E 6F 20 73 65 72 +    .byte 'No server response!',155,0
   579 4459 38			   sec
   580 445A 60			   rts
   581 445B			OKa
   582 445B AD F6 4A 18 69 30 +     adb drive #$30
   583 4464 20 CC 47		jsr Printf
   584 4467 2D 20 53 6C 6F 74 + 	.byte '- Slot %c: %s',155,0
   585 4476 F6 4A F9 4A			.word Drive, Path
   586 447A 18				clc
   587 447B 60				rts	
   588 				.endp
   589
   590
   591 				//
   592 				//	DR: List Last RCL dir
   593 				//
   594
   595 447C			.proc ListDir
   596 447C 20 CC 47		    jsr Printf
   597 447F 4C 69 73 74 20 73 +    .byte 'List server RCL folder',155,155,0
   598 4498 A2 00		    ldx #$00
   599 449A 8E 1D 4C		    stx lp
   600 449D			loopb    
   601 449D A9 00		    lda #DCB.GetDR
   602 449F 20 90 47		    jsr SetUpDCB
   603 44A2 AD 1D 4C 8D 0A 03	    mva lp DAUX1
   604 44A8 20 59 E4		    jsr SIOV
   605 44AB 10 1A		    bpl OKb
   606 44AD 20 CC 47		    jsr Printf
   607 44B0 4E 6F 20 73 65 72 +     .byte 'No server response!',155,0
   608 44C5 38			    sec
   609 44C6 60			    rts
   610 44C7			OKb
   611 44C7 20 CC 47		    jsr Printf
   612 44CA 9B 25 73 20 9B 00	   .byte 155,'%s ',155,0
   613 44D0 1F 4B		   .word IOBuf
   614 44D2 AE 1D 4C			ldx lp
   615 44D5 E0 00			cpx #00
   616 44D7 F0 21			beq doneb
   617 44D9 20 CC 47			jsr Printf
   618 44DC 20 6D 6F 72 65 2E + 	.byte ' more..(q=quit)',0
   619 44EC 20 83 47			jsr GetKey
   620 44EF C9 51			cmp #'Q'
   621 44F1 F0 07			beq doneb
   622 44F3 C9 71			cmp #'q'
   623 44F5 F0 03			beq doneb
   624 44F7 4C 9D 44			jmp loopb
   625 44FA			doneb	
   626 44FA 18				clc
   627 44FB 60				rts	
   628 				.endp
   629
   630
   631 				//
   632 				//  Toggle Auto Commit
   633 				//
   634 44FC			.proc CommitOn
   635 44FC A2 01		      LDX #01
   636 44FE 4C 03 45		      jmp ToggleCommit
   637 				.endp      
   638 4501			.proc Commitoff
   639 4501 A2 00		      LDX #00
   640 				.endp      
   641
   642 4503			.proc ToggleCommit
   643 4503 8E F3 4A		    stx ArgFlag
   644 4506 20 CA 40			jsr GetDrvWC
   645 4509 B0 75			bcs Error
   646 450B 8D F6 4A			sta Drive
   647 450E 20 C1 40			jsr GetNextChar
   648 4511 90 6D			bcc Error
   649
   650 4513 A9 07			lda #DCB.AutoToggle
   651 4515 20 90 47			jsr SetUpDCB
   652 4518 AD F6 4A 8D 0A 03		mva Drive   DAUX1
   653 451E AD F3 4A 8D 0B 03		mva ArgFlag DAUX2
   654 4524 20 59 E4			jsr SIOV
   655 4527 10 22			bpl OK2
   656 4529 20 CC 47			jsr Printf
   657 452C 45 72 72 6F 72 20 + 	.byte 'Error toggling auto-commit!',155,0
   658 4549 38				sec
   659 454A 60				rts
   660 454B			OK2
   661 454B AD F6 4A			lda Drive
   662 454E C9 FA			cmp #-6
   663 4550 F0 31			beq AllDrives
   664 4552 20 8C 47			jsr MakeDriveID
   665 4555 8D F7 4A			sta DriveID1
   666 4558 20 CC 47			jsr Printf
   667 455B 41 75 74 6F 2D 63 + 	.byte 'Auto-commit toggled on drive %c',155,0
   668 457C F7 4A			.word DriveID1
   669 457E 38				sec
   670 457F 60				rts
   671 4580			Error
   672 4580 4C AB 45			jmp Usage
   673 4583			AllDrives
   674 4583 20 CC 47			jsr Printf
   675 4586 41 75 74 6F 2D 63 + 	.byte 'Auto-commit toggled on all drives',155,0
   676 45A9 38				sec
   677 45AA 60				rts
   678 					.endp
   679
   680 				//
   681 				//	Show command usage
   682 				//
   683 45AB			Usage
   684 45AB 20 CC 47			jsr Printf
   685 45AE 55 73 61 67 65 3A + 	.byte 'Usage: RCL command',155
   686 45C1 9B				.byte 155
   687 45C2 43 6F 6D 6D 61 6E + 	.byte 'Commands:',155
   688 45CC 9B				.byte 155
   689 45CD 54 53 3A 20 53 65 + 	.byte 'TS: Set time/date',155
   690 45DF 54 4F 3A 20 53 65 + 	.byte 'TO: Set time/date and enable TD Line',155
   691 4604 54 46 3A 20 53 65 + 	.byte 'TF: Set time/date and disable TD Line',155
   692 462A 9B 00			.byte 155,0
   693 					
   694 462C 20 CC 47			jsr Printf
   695 462F 44 4D 66 6E 61 6D + 	.byte 'DMfname.ext:   Existing Image Mount',155
   696 4653 44 4E 66 6E 61 6D + 	.byte 'DNfname.ext.x: New Image Mount',155
   697 4672 9B				.byte 155
   698 4673 20 78 3A 20 31 3A + 	.byte ' x: 1:SSSD 2:SSED 3:SSDD',155
   699 468C 20 20 20 20 34 3A + 	.byte '    4:DSDD 5:DDHD 6:QDHD',155
   700 46A5 9B 00			.byte 155,0
   701
   702 46A7 20 CC 47			jsr Printf
   703 46AA 44 55 5B 64 2F 2A + 	.byte 'DU[d/*]: Unmount disk/all disks',155
   704 46CA 44 53 5B 64 64 5D + 	.byte 'DS[dd]:  Swap Disks',155
   705 46DE 44 41 5B 64 2F 2A + 	.byte 'DA[d/*]: Auto-commit On disk/all',155 
   706 46FF 44 4F 5B 64 2F 2A + 	.byte 'DO[d/*]: Auto-commit Off disk/all',155
   707 4721 44 44 5B 64 2F 2A + 	.byte 'DD[d/*]: Display disk name/all slots',155
   708 4746 44 52 20 20 20 20 + 	.byte 'DR       List server images',155
   709 4762 00				.byte 0
   710 4763 38				sec
   711 4764 60				rts
   712
   713
   714 4765				.proc Exit
   715 4765 20 CC 47			jsr Printf
   716 4768 50 72 65 73 73 20 + 	.byte 'Press a key to quit',155,0
   717 477D 4C 83 47			jmp GetKey
   718 					.endp
   719
   720 					
   721 4780				.proc Crunch
   722 4780 4C FF FF			jmp $FFFF
   723 					.endp
   724 					
   725 4783				.proc GetKey
   726 4783 AD 25 E4			lda $E425
   727 4786 48				pha
   728 4787 AD 24 E4			lda $E424
   729 478A 48				pha
   730 478B 60				rts
   731 					.endp
   732 					
   733 					
   734 				//
   735 				//	Make drive ID
   736 				//	Pass drive number in A
   737 				//	This is unexpectedly simple since drive letters and numbers all have the same transition applied
   738 				//
   739
   740 478C				.proc MakeDriveID
   741 				;	cmp #10
   742 				;	bcs @+
   743 478C 18				clc
   744 478D 69 30			adc #'0'	; everything gets $30 added
   745 478F 60				rts
   746 				;@
   747 				;	clc
   748 				;	adc #'A'-1
   749 				;	rts
   750 					.endp
   751
   752
   753
   754 				//
   755 				//	Set up DCB for SIO call
   756 				//	Pass DCB number in A
   757 				//
   758 					
   759 4790				.proc SetUpDCB
   760 4790 A8				tay
   761 4791 BE AB 47			ldx DCBIndex,y	; we could multiply by 10 then add nine, but a table is easier
   762 4794 A0 09			ldy #9
   763 4796			Loop
   764 4796 BD 90 4A			lda DCBTable,x
   765 4799 99 02 03			sta DComnd,y
   766 479C CA				dex
   767 479D 88				dey
   768 479E 10 F6			bpl Loop
   769 47A0 A9 46 8D 00 03		mva #$46 DDevic	; ddevic and dunit are common to all
   770 47A5 A9 01 8D 01 03		mva #$01 DUnit
   771 47AA 60				rts
   772 47AB			DCBIndex
   773 47AB 09 13 1D 27 31 3B + 	.byte 9,19,29,39,49,59,69,79,89
   774 					.endp
   775 					
   776 					
   777 					
   778 47B4				icl 'printf.asm'
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/printf.asm
     1 				;  printf.s - RespeQt printf library
     2 				;
     3 				;  Copyright (c) 2016 by Jonathan Halliday <fjc@atari8.co.uk>
     4 				;
     5 				;  This program is free software; you can redistribute it and/or modify
     6 				;  it under the terms of the GNU General Public License as published by
     7 				;  the Free Software Foundation; either version 2 of the License, or
     8 				;  (at your option) any later version.
     9 				;
    10 				;  This program is distributed in the hope that it will be useful,
    11 				;  but WITHOUT ANY WARRANTY; without even the implied warranty of
    12 				;  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    13 				;  GNU General Public License for more details.
    14 				;
    15 				;  You should have received a copy of the GNU General Public License
    16 				;  along with this program; if not, write to the Free Software
    17 				;  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
    18 				;
    19
    20 				//
    21 				//	Tiny Printf
    22 				//	Temp1: String pointer
    23 				//	Temp3: Arg pointer
    24 				//	ArgIndex: index into args (offset from start of string)
    25 				//	StringIndex: index into string
    26 				//
    27
    28
    29 				//
    30 				//	Get pointer to next arg in Temp3
    31 				//
    32
    33 47B4				.proc GetNextArg
    34 47B4 A4 89			ldy ArgIndex
    35 47B6 B1 80			lda (Temp1),y
    36 47B8 85 84			sta Temp3
    37 47BA C8				iny
    38 47BB B1 80			lda (Temp1),y
    39 47BD 85 85			sta Temp3+1
    40 47BF C8				iny
    41 47C0 84 89			sty ArgIndex
    42 47C2 A0 00			ldy #0		; leave 0 in Y
    43 47C4 60				rts
    44 					.endp
    45
    46
    47 				//
    48 				//	Create arg pointer
    49 				//
    50
    51 47C5				.proc GetArgPointer
    52 47C5 20 E7 47			jsr StrLen	; step past string argument
    53 47C8 C8				iny		; skip trailing NUL
    54 47C9 84 89			sty ArgIndex
    55 47CB 60				rts
    56 					.endp
    57
    58
    59
    60
    61 				//
    62 				//	In-line entry point
    63 				//
    64
    65 47CC				.proc Printf
    66 47CC 68				pla		; get address of in-line string
    67 47CD 18				clc
    68 47CE 69 01			adc #1
    69 47D0 A8				tay		; save LSB	
    70 47D1 68				pla		; get MSB
    71 47D2 69 00			adc #0
    72 47D4 AA				tax		; put MSB in X
    73 47D5 98				tya		; put LSB in A
    74 47D6 20 EF 47			jsr PrintfAX	; Main expects string address in A,X
    75 47D9			Return
    76 47D9 A5 80			lda Temp1
    77 47DB 18				clc
    78 47DC 65 89			adc ArgIndex
    79 47DE 85 80			sta Temp1
    80 47E0 90 02			bcc @+
    81 47E2 E6 81			inc Temp1+1
    82 47E4			@
    83 47E4 6C 80 00			jmp (Temp1)
    84 					.endp
    85
    86
    87
    88 				//
    89 				//	Get string length
    90 				//
    91
    92 47E7				.proc StrLen
    93 47E7 A0 FF			ldy #$FF
    94 47E9			@
    95 47E9 C8				iny
    96 47EA B1 80			lda (Temp1),y
    97 47EC D0 FB			bne @-
    98 47EE 60				rts
    99 					.endp
   100 					
   101
   102 					
   103 					
   104
   105
   106
   107
   108 47EF				.proc PrintfAX
   109 47EF				stax Temp1
Macro: STAX [Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/equ.asm]
     1 47EF 85 80			sta TEMP1
     2 47F1 86 81			stx TEMP1+1
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/printf.asm
   110 47F3			NoAX
   111 47F3 A9 00			lda #0
   112 47F5 85 8B			sta StringIndex
   113 47F7 20 C5 47			jsr GetArgPointer
   114 47FA			Loop
   115 47FA A4 8B			ldy StringIndex
   116 47FC B1 80			lda (Temp1),y
   117 47FE F0 4B			beq Done
   118 4800 C9 25			cmp #'%'
   119 4802 D0 40			bne PrintChar
   120 4804 E6 8B			inc StringIndex
   121 4806 C8				iny
   122 4807 B1 80			lda (Temp1),y
   123 4809 F0 40			beq Done
   124 480B C9 25			cmp #'%'
   125 480D F0 35			beq PrintChar
   126 480F 20 50 48			jsr GetFieldWidth
   127 4812 B1 80			lda (Temp1),y
   128 4814 AE 34 48			ldx PFControlTab
   129 4817			FindIt
   130 4817 DD 34 48			cmp PFControlTab,x
   131 481A F0 05			beq FoundIt
   132 481C CA				dex
   133 481D D0 F8			bne FindIt
   134 481F F0 26			beq NextChar
   135 					
   136 4821			FoundIt
   137 4821 A9 48			lda #> [NextChar-1]
   138 4823 48				pha
   139 4824 A9 46			lda #< [NextChar-1]
   140 4826 48				pha
   141 4827 CA				dex
   142 4828 8A				txa
   143 4829 0A				asl
   144 482A AA				tax
   145 482B BD 3B 48			lda PFControlAddr+1,x
   146 482E 48				pha
   147 482F BD 3A 48			lda PFControlAddr,x
   148 4832 48				pha
   149 4833 60				rts
   150 				;
   151
   152 4834			PFControlTab
   153 4834 05				.byte 5
   154 4835 63 70 73 62 78		.byte 'cpsbx'
   155 483A			PFControlAddr
   156 483A 80 48			.word PfChar-1
   157 483C 91 48			.word PfPtr-1
   158 483E A3 48			.word PfString-1
   159 4840 DA 48			.word PfByte-1
   160 4842 A9 48			.word PfHex-1
   161
   162 4844			PrintChar
   163 4844 20 1D 49			jsr PutChar
   164 4847			NextChar
   165 4847 E6 8B			inc StringIndex
   166 4849 D0 AF			bne Loop
   167 484B			Done
   168 484B A9 00 85 83			mva #0 Temp2+1
   169 484F 60				rts
   170 					.endp
   171
   172
   173
   174 4850				.proc GetFieldWidth
   175 4850 A9 00			lda #0
   176 4852 85 8A			sta FieldWidth
   177 4854 85 88			sta LeadingZeroFlag
   178 4856 AA				tax
   179 4857			Loop
   180 4857 B1 80			lda (Temp1),y
   181 4859 C9 3A			cmp #'9'+1
   182 485B B0 21			bcs Done
   183 485D 38				sec
   184 485E E9 30			sbc #'0'
   185 4860 90 1C			bcc Done	
   186 4862 D0 06			bne @+
   187 4864 E0 00			cpx #0		; if first field width digit is zero, set leading zero flag
   188 4866 D0 02			bne @+
   189 4868 C6 88			dec LeadingZeroFlag
   190 486A			@
   191 486A 85 84			sta Temp3
   192 486C A5 8A			lda FieldWidth
   193 486E 0A				asl @		; fieldwidth * 2
   194 486F 85 85			sta Temp3+1
   195 4871 0A				asl @
   196 4872 0A				asl @		; fieldwidth * 8
   197 4873 18				clc
   198 4874 65 85			adc Temp3+1	; (fieldwidth*2) + (fieldwidth*8)
   199 4876 65 84			adc Temp3	; add in units
   200 4878 85 8A			sta FieldWidth
   201 487A E8				inx
   202 487B C8				iny
   203 487C D0 D9			bne Loop
   204 487E			Done
   205 487E 84 8B			sty StringIndex
   206 4880 60				rts
   207 					.endp
   208 					
   209 					
   210
   211 4881				.proc PfChar
   212 4881 20 B4 47			jsr GetNextArg	; leaves 0 in Y
   213 4884 B1 84			lda (Temp3),y
   214 4886 A6 8A			ldx FieldWidth
   215 4888 D0 01			bne Loop
   216 488A E8				inx
   217 488B			Loop
   218 488B 20 1D 49			jsr PutChar	; doesn't clobber registers
   219 488E CA				dex
   220 488F D0 FA			bne Loop
   221 4891 60				rts
   222 					.endp
   223
   224
   225
   226 4892				.proc PfPtr
   227 4892 20 B4 47			jsr GetNextArg
   228 4895 A0 01			ldy #1
   229 4897 B1 84			lda (Temp3),y
   230 4899 AA				tax
   231 489A 88				dey
   232 489B B1 84			lda (Temp3),y
   233 489D 85 84			sta Temp3
   234 489F 86 85			stx Temp3+1
   235 48A1 4C 10 49			jmp PFPrintStr
   236 					.endp
   237
   238
   239
   240 48A4				.proc PfString
   241 48A4 20 B4 47			jsr GetNextArg
   242 48A7 4C 10 49			jmp PFPrintStr
   243 					.endp
   244
   245
   246 					
   247 				//
   248 				//	Display Hex/BCD
   249 				//
   250
   251 48AA				.proc PfHex
   252 48AA 20 B4 47			jsr GetNextArg
   253 48AD B1 84			lda (Temp3),y
   254 48AF 48				pha
   255 48B0 4A				lsr @
   256 48B1 4A				lsr @
   257 48B2 4A				lsr @
   258 48B3 4A				lsr @
   259 48B4 D0 04			bne NotZero
   260 48B6 24 88			bit LeadingZeroFlag
   261 48B8 10 07			bpl @+
   262 48BA			NotZero
   263 48BA A8				tay
   264 48BB B9 CB 48			lda HexTable,y
   265 48BE 20 1D 49			jsr PutChar
   266 48C1			@
   267 48C1 68				pla
   268 48C2 29 0F			and #$0F
   269 48C4 A8				tay
   270 48C5 B9 CB 48			lda HexTable,y
   271 48C8 4C 1D 49			jmp PutChar
   272 48CB			HexTable
   273 48CB 30 31 32 33 34 35 + 	.byte '0123456789ABDCEF'
   274 					.endp
   275
   276
   277
   278
   279 				//
   280 				//	Display decimal byte
   281 				//
   282
   283 48DB				.proc PfByte
   284 48DB 20 B4 47			jsr GetNextArg
   285 48DE B1 84			lda (Temp3),y
   286 48E0 A2 00			ldx #0
   287 48E2			Loop1
   288 48E2 C9 64			cmp #100
   289 48E4 90 05			bcc HundredsDone
   290 48E6 E9 64			sbc #100
   291 48E8 E8				inx
   292 48E9 D0 F7			bne Loop1
   293 48EB			HundredsDone
   294 48EB 48				pha	; save remainder
   295 48EC 8A				txa
   296 48ED F0 03			seq
   297 48EF 20 06 49			jsr PutDigit
   298 48F2 68				pla
   299 48F3 A2 00			ldx #0
   300 48F5			Loop
   301 48F5 C9 0A			cmp #10
   302 48F7 90 05			bcc TensDone
   303 48F9 E9 0A			sbc #10
   304 48FB E8				inx
   305 48FC D0 F7			bne Loop
   306 48FE			TensDone
   307 48FE 48				pha
   308 48FF 8A				txa
   309 4900 F0 03			seq
   310 4902 20 06 49			jsr PutDigit
   311 4905 68				pla
   312 4906			PutDigit
   313 4906 18				clc
   314 4907 69 30			adc #'0'
   315 4909 4C 1D 49			jmp PutChar
   316 					.endp	
   317 					
   318 					
   319 					
   320 					
   321
   322 				//
   323 				//	Print plain string in A,X
   324 				//
   325 					
   326 490C				.proc PutStrAX
   327 490C				stax Temp3	; fall into PFPrintStr
Macro: STAX [Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/equ.asm]
     1 490C 85 84			sta TEMP3
     2 490E 86 85			stx TEMP3+1
Source: /home/paul/eclipse-workspace/atari_rcl_RealDos/printf.asm
   328 					.endp
   329
   330
   331 4910				.proc PFPrintStr
   332 4910 A0 00			ldy #0
   333 4912			@
   334 4912 B1 84			lda (Temp3),y
   335 4914 F0 06			beq Done
   336 4916 20 1D 49			jsr PutChar
   337 4919 C8				iny
   338 491A D0 F6			bne @-
   339 491C			Done
   340 491C 60				rts
   341 					.endp
   342 					
   343 					
   344
   345 					
   346 				//
   347 				//	Put character
   348 				//
   349
   350 491D				.proc PutChar
   351 491D 84 86			sty Temp4
   352 491F 86 87			stx Temp4+1
   353 4921 48				pha
   354 4922 A9 00			lda #0
   355 4924 AA				tax
   356 4925 9D 48 03			sta icblen,x
   357 4928 9D 49 03			sta icblen+1,x
   358 492B A9 0B 9D 42 03		mva #$0B iccom,x
   359 4930 68				pla
   360 4931 20 56 E4			jsr ciov
   361 4934 A4 86			ldy Temp4
   362 4936 A6 87			ldx Temp4+1
   363 4938 60				rts
   364 					.endp
   365
   366 					
   367 4939				.proc ToUpper
   368 4939 C9 7B			cmp #'z'+1
   369 493B B0 06			bcs NLow
   370 493D C9 61			cmp #'a'
   371 493F 90 02			bcc NLow
   372 4941 E9 20			sbc #32
   373 4943			NLow
   374 4943 60				rts
   375 					.endp
   376 					
   377
   378 				//
   379 				//	input 1 character
   380 				//
   381 4944				.proc Input1
   382 4944 20 6A 49			jsr Input
   383 4947 C0 03			cpy #03
   384 4949 30 1D			bmi ok1
   385 494B 20 CC 47			jsr Printf
   386 494E 9B 45 6E 74 65 72 + 	.byte 155,'Enter only 1 character',0
   387 4966 38				sec
   388 4967 60				rts
   389 4968			ok1
   390 4968 18			    clc
   391 4969 60				rts
   392 					.endp
   393
   394 						
   395 				//
   396 				//	input characters
   397 				//				
   398 496A				.proc Input
   399 496A A9 00			lda #0
   400 496C AA				tax
   401 496D A9 FF			lda #$ff
   402 496F 9D 48 03			sta icblen,x
   403 4972 A9 00			lda #$00
   404 4974 9D 49 03			sta icblen+1,x
   405 4977 A9 91			lda #< [InputBuf]
   406 4979 9D 44 03			sta icbadr,x
   407 497C A9 49			lda #> [InputBuf]
   408 497E 9D 45 03			sta icbadr+1,x
   409 4981 A9 05 9D 42 03		mva #$05 iccom,x
   410 4986 20 56 E4			jsr ciov
   411 4989 AD 91 49		    lda InputBuf
   412 498C BC 48 03		    ldy icblen,x
   413 498F 18			    clc
   414 4990 60				rts
   415 					.endp
   416 					
   417 4991			InputBuf
   418 = 4991				.ds 255
   419 					
   779
   780 4A90			DCBTable
   781
   782 4A90			DCBGetDR
   783 4A90-4AF8> 91			.byte Cmd.GetDR	  ; command
   784 4A91 40				.byte $40		  ; dstats
   785 4A92 1F 4B			.word IOBuf       ; buffer address
   786 4A94 06 00			.byte $06,$00	  ; timeout, dunuse
   787 4A96 FF 00			.word $FF		  ; buffer length
   788 4A98 00 00			.byte $00,$00	  ; aux1, aux2
   789 4A9A			DCBGetSL
   790 4A9A 92				.byte Cmd.GetSL	  
   791 4A9B 40				.byte $40		  
   792 4A9C F9 4A			.word Path        
   793 4A9E 06 00			.byte $06,$00	  
   794 4AA0 16 00			.word $16		  
   795 4AA2 00 00			.byte $00,$00	  
   796 4AA4			DCBGetTD
   797 4AA4 93				.byte Cmd.GetTD	
   798 4AA5 40				.byte $40		
   799 4AA6 1F 4B			.word IOBuf		
   800 4AA8 06 00			.byte $06,$00	
   801 4AAA 06 00			.word $06		
   802 4AAC 00 00			.byte $00,$00	
   803 4AAE			DCBSwap
   804 4AAE 94				.byte Cmd.Swap
   805 4AAF 00				.byte $00
   806 4AB0 1F 4B			.word IOBuf
   807 4AB2 06 00			.byte $06,$00
   808 4AB4 00 00			.word 0
   809 4AB6 00 00			.byte $00,$00
   810 4AB8			DCBUnmount
   811 4AB8 95				.byte Cmd.Unmount
   812 4AB9 00				.byte $00
   813 4ABA 1F 4B			.word IOBuf
   814 4ABC 06 00			.byte $06,$00
   815 4ABE 00 00			.word 0
   816 4AC0 00 00			.byte $00,$00
   817 4AC2			DCBMount
   818 4AC2 96				.byte Cmd.Mount
   819 4AC3 80				.byte $80
   820 4AC4 1F 4B			.word IOBuf
   821 4AC6 06 00			.byte $06,$00
   822 4AC8 0C 00			.word $0C
   823 4ACA 00 00			.byte $00,$00
   824 4ACC			DCBCreateAndMount
   825 4ACC 97				.byte Cmd.CreateAndMount
   826 4ACD 80				.byte $80
   827 4ACE 1F 4B			.word IOBuf
   828 4AD0 06 00			.byte $06,$00
   829 4AD2 0E 00			.word $0E
   830 4AD4 00 00			.byte $00,$00
   831 4AD6			DCBAutoToggle
   832 4AD6 98				.byte Cmd.AutoToggle
   833 4AD7 00				.byte $00
   834 4AD8 1F 4B			.word IOBuf
   835 4ADA 06 00			.byte $06,$00
   836 4ADC 00 00			.word 0
   837 4ADE 00 00			.byte $00,$00
   838 4AE0			DCBGetDrvNum
   839 4AE0 96				.byte Cmd.Mount
   840 4AE1 40				.byte $40
   841 4AE2 1F 4B			.word IOBuf
   842 4AE4 06 00			.byte $06,$00
   843 4AE6 01 00			.word $01
   844 4AE8 01 00			.byte $01,$00
   845 					
   846
   847 4AEA			Symbol
   848 4AEA 49 5F 54 44 4F 4E + 	.byte 'I_TDON  ',0
   849
   850 				 	
   851 4AF3			ArgFlag
   852 4AF3 00				.byte 0
   853 4AF4			CreateFlag
   854 4AF4 00				.byte 0
   855 4AF5			Slot
   856 4AF5 00				.byte 0
   857 4AF6			Drive
   858 4AF6 00				.byte 0
   859 4AF7			DriveID1
   860 4AF7 00				.byte 0
   861 4AF8			DriveID2
   862 4AF8 00				.byte 0
   863 4AF9			Path 
   864 = 4AF9				.ds 22
   865 4B0F			Filename
   866 = 4B0F				.ds 16		
   867 4B1F			IOBuf
   868 = 4B1F				.ds 254
   869 4C1D			lp
   870 = 4C1D			    .ds   1	
   871 					
   872 02E0-02E1> 00 40			run Start
   873 					
